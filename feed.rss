<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>vickcoo</title><description>iOS Developer</description><link>https://vickcoo.github.io</link><language>zh-Hant</language><lastBuildDate>Thu, 16 Nov 2023 17:38:37 +0800</lastBuildDate><pubDate>Thu, 16 Nov 2023 17:38:37 +0800</pubDate><ttl>250</ttl><atom:link href="https://vickcoo.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://vickcoo.github.io/posts/IDevelopASimplyToDoApp@zh-Hant</guid><title>我開發了一款簡單但也有細節的 To-Do App</title><description>說明了很多在這個 App 開發時使用到的技術細節，適合給剛入門的人參考。</description><link>https://vickcoo.github.io/posts/IDevelopASimplyToDoApp@zh-Hant</link><pubDate>Tue, 7 Nov 2023 14:43:00 +0800</pubDate><content:encoded><![CDATA[<h2>前言</h2><blockquote><p>我是 vickcoo，是一名剛要轉職成為 iOS 工程師的人，所以有任何意見想提出我都非常樂意！</p></blockquote><p>為什麼我要寫這一篇文章<s>（aka. 筆記）</s>呢？因為如標題我要開發一個很簡單的 To Do App，一方面這是個很好拿來當做第一個練手的題材，以及為了求職所準備的，因為我完全沒有 iOS 開發的工作經驗，以前都是寫 Web 所以想要有作品即使它不是什麼有創意或是複雜的程式，但比起口頭上說我會了些什麼，不如拿出東西來展現也比較有說服力！</p><p>本篇就會介紹開發過程中，我認為值得紀錄下供後人以及我自己有需要的時後可以參考。</p><p>需要看原始碼的可以到 GitHub <a href="https://github.com/vickcoo/odot">vickcoo/odot</a> 中查看。</p><h2>畫面展示</h2><img src="https://vickcoo.github.io/images/SimpleToDoAppRecord/Showcase.jpeg" alt="Showcase"/><div class="caption">主畫面 / 編輯畫面 / 資料未保存提醒</div><h2>功能介紹 &amp; 技術細節</h2><p>技術含量或許不多，不過對於不熟悉這些技術或是剛入行的 iOS 工程師們能有點幫助，以下是大綱沒有順序的分別介紹各個技術細節。</p><ul><li>新增待辨項目：會新開頁面來提供畫面輸入資料來新增</li><li>編輯待辨項目：會新開頁面來提供畫面輸入資料來更新，若<strong>資料變更未儲存</strong>並點擊取消會彈出訊息讓你確認是否要儲存或放棄修改</li><li>提醒通知：可以設定指定的日期時間來發送通知</li><li>持久化存儲：資料都是儲存在本地端（使用者的設備上）</li><li>多國語系：目前只支持中文以及英文</li><li>自訂 Cell：除了基本的標題還自訂了 CheckBox 來提供點擊完成該待辨項目</li><li>待辨項目的 UITableView<ul><li>沒有任何資籵時會顯示文字來告訴使用者，增強使用者體驗</li><li>基本的排序、刪除、新增功能</li><li>鍵盤：</li><li>會自動調整筆記欄位的高度，簡單來說就是鍵盤彈出不會擋到要輸入文字的地方</li><li>點擊非輸入框的位置<strong>隱藏鍵盤</strong></li><li>點擊完成（Done）按鈕<strong>隱藏鍵盤</strong></li><li>點擊新增進到畫面時會<strong>自動將焦點放在標題欄</strong>，並且<strong>彈出鍵盤</strong></li><li>在標題<strong>欄點擊鍵盤的 Next 鍵會將焦點放在筆記欄</strong></li></ul></li></ul><ul><li>其他<ul><li>轉跳到系統的設定</li><li>NotificationCenter</li></ul></li></ul><h2>大綱</h2><p>技術含量或許不深，不過對於不熟悉這些技術或是剛入行的 iOS 工程師們能有點幫助，以下是大綱沒有順序的分別介紹各個技術細節，可以利用下面的 關鍵字去找文章中你想看的部分。</p><ul><li>UITableView<ul><li>UITableViewDataSource</li><li>UITableViewDelegate</li><li>沒有資料時顯示文字</li></ul></li></ul><ul><li>多國語系</li><li>跑 Simulator 時更方便的測試不同語言</li><li>本地端資料儲存</li><li>NotificationCenter 監聽事件</li><li>鍵盤處理<ul><li>彈出鍵盤</li><li>文字輸入框被鍵盤擋住</li><li>隱藏鍵盤：在鍵盤上方新增按鈕</li><li>隱藏鍵盤：點擊畫面其餘空白部分</li></ul></li></ul><ul><li>發送通知</li><li>轉跳到系統的設定</li><li>利用 Button 實現 CheckBox 功能</li></ul><h2>UITableView</h2><p>入門首先最常接觸的大概就屬 <a href="https://developer.apple.com/documentation/uikit/uitableview">UITableView</a> 了吧，主要會要遵循 <a href="https://developer.apple.com/documentation/uikit/uitableviewdatasource">UITableViewDataSource</a> 跟 <a href="https://developer.apple.com/documentation/uikit/uitableviewdelegate">UITableViewDelegate</a> ，而這兩個 Protocol 的職責分別是負責什麼呢？</p><h3>UITableViewDataSource</h3><p>如它的名字所代表的就是關於<strong>資料</strong>方面的處理。</p><p>其中之一必須要實作的是這個 <code>cellForRowAt</code>，它所要做的是告訴 UITableView 你要讓 Cell（指的是每一行資料） 怎麼樣呈現以及要什麼資料，接下來這個 <code>numberOfRowInSection</code> 也必須要實作，它要做的事就是告訴 UITableView 你的畫面中要顯示出多少筆資料。</p><pre><code><span class="comment">// 要呈現什麼樣的資料</span>
<span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span>

<span class="comment">// 要顯示的資料筆數</span>
<span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span>
</code></pre><h3>UITableViewDelegate</h3><p>它是負責處理一些對 UITableView 的操作所觸發的事件，例子如下：</p><p>要對資料做排序需實作 <code>moveRowAt</code>，可以多利用 Autocomplete 輸入關鍵字 <code>moveRowAt</code>；要刪除資料需實作 <code>commit</code>，一樣可以輸入關鍵字 <code>commit</code>。</p><pre><code><span class="comment">// 排序資料</span>
<span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, moveRowAt sourceIndexPath: <span class="type">IndexPath</span>, to destinationIndexPath: <span class="type">IndexPath</span>)

<span class="comment">// 刪除資料</span>
<span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, commit editingStyle: <span class="type">UITableViewCell</span>.<span class="type">EditingStyle</span>, forRowAt indexPath: <span class="type">IndexPath</span>)
</code></pre><h3>當沒有資料時顯示文字</h3><blockquote><p>這個功能的實現是參考這篇文章 <a href="https://medium.com/@mtssonmez/handle-empty-tableview-in-swift-4-ios-11-23635d108409">Handle Empty TableView in Swift 4 &amp; iOS 11</a></p></blockquote><p>這個主要是讓使用者體驗更好一點，沒有任何資料時讓使用者知道，或是提供訊息告訴他們要去哪新增資料。主要的概念是當 UITableView 沒有資料的時候設定一個自訂的 <code>UIView</code>，有資料的時候就將這個自訂的刪除。</p><p>實作主要分兩部分，幫 <code>UITableView</code> 擴充兩個 Function：</p><ol><li><code>setEmptyView</code> 就是建立自訂的 View 裡面很簡單就是放兩個 <code>UILabel</code> 來顯示文字</li><li><code>removeEmptyView</code> 就是把這個 View 刪除</li></ol><pre><code><span class="keyword">extension</span> <span class="type">UITableView</span> {
    <span class="comment">/// Display a message on the `UITableView` center, notice you need to call `removeEmptyView()` when table hasn't any row.</span>
    <span class="keyword">func</span> setEmptyView(title: <span class="type">String</span>, message: <span class="type">String</span>) {
        <span class="keyword">let</span> backgroundView = <span class="type">UIView</span>()
        
        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>()
        titleLabel.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span>
        titleLabel.<span class="property">text</span> = title
        titleLabel.<span class="property">font</span> = .<span class="call">systemFont</span>(ofSize: <span class="number">18</span>)
        titleLabel.<span class="property">textColor</span> = .<span class="dotAccess">label</span>
        backgroundView.<span class="call">addSubview</span>(titleLabel)
        
        <span class="keyword">let</span> messageLabel = <span class="type">UILabel</span>()
        messageLabel.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span>
        messageLabel.<span class="property">text</span> = message
        messageLabel.<span class="property">font</span> = .<span class="call">systemFont</span>(ofSize: <span class="number">16</span>)
        messageLabel.<span class="property">textColor</span> = .<span class="dotAccess">secondaryLabel</span>
        backgroundView.<span class="call">addSubview</span>(messageLabel)
        
        <span class="type">NSLayoutConstraint</span>.<span class="call">activate</span>([
            titleLabel.<span class="property">centerXAnchor</span>.<span class="call">constraint</span>(equalTo: backgroundView.<span class="property">centerXAnchor</span>),
            titleLabel.<span class="property">centerYAnchor</span>.<span class="call">constraint</span>(equalTo: backgroundView.<span class="property">centerYAnchor</span>, constant: -<span class="number">6</span>),
            messageLabel.<span class="property">centerXAnchor</span>.<span class="call">constraint</span>(equalTo: backgroundView.<span class="property">centerXAnchor</span>),
            messageLabel.<span class="property">centerYAnchor</span>.<span class="call">constraint</span>(equalTo: titleLabel.<span class="property">bottomAnchor</span>, constant: <span class="number">12</span>)
        ])
        
        <span class="keyword">self</span>.<span class="property">backgroundView</span> = backgroundView
    }
    
    <span class="comment">/// Clean the message that  you have set before by `setEmptyView(title: String, message: String)`</span>
    <span class="keyword">func</span> removeEmptyView() {
        <span class="keyword">self</span>.<span class="property">backgroundView</span> = <span class="keyword">nil</span>
    }
}
</code></pre><ol start="2"><li>第二個要實作的就是何時要顯示出這個自訂的 View，何時要刪除？想想看我們前面介紹的 <code>UITableViewDataSource</code>，這裡是很好判斷的地方，重點在第 2 行到第 6 行，判斷有沒有資料來決定要不要顯示自訂的 View</li></ol><pre><code><span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">if</span> myData.<span class="property">isEmpty</span> {
        tableView.<span class="call">setEmptyView</span>(title: title, message: message)
    } <span class="keyword">else</span> {
        tableView.<span class="call">removeEmptyView</span>()
    }

    <span class="keyword">return</span> myData.<span class="property">count</span>
}
</code></pre><img src="https://vickcoo.github.io/images/SimpleToDoAppRecord/UITableView-EmptyView.png" alt="UITableView-EmptyView"/><div class="caption">沒有資料時顯示文字資訊</div><p><strong>如何切換編輯模式</strong></p><blockquote><p>這裡指的是在 iOS App 中常見的編輯按鈕點擊後，右邊會出現可以拖動排序，左邊會有紅色減號可以刪除。</p></blockquote><p>將你設定的按鈕點擊事件中放入這段程式碼，就能夠做編輯的切換。</p><pre><code><span class="comment">// @IBOutlet var tableView: UITableView!</span>

<span class="keyword">if</span> tableView.<span class="property">isEditing</span> {
    tableView.<span class="call">setEditing</span>(<span class="keyword">false</span>, animated: <span class="keyword">true</span>)
} <span class="keyword">else</span> {
    tableView.<span class="call">setEditing</span>(<span class="keyword">true</span>, animated: <span class="keyword">true</span>)
}
</code></pre><img src="https://vickcoo.github.io/images/SimpleToDoAppRecord/UITableView-Editing.png" alt="UITableView-Editing"/><div class="caption">UITableView 編輯模式</div><h2>多國語系 Localization</h2><p>這個 App 也有多語言支持（也只有中文跟英文）。</p><blockquote><p>使用的是在 Xcode 15 推出的 <a href="https://developer.apple.com/documentation/Xcode/localizing-and-varying-text-with-a-string-catalog">String Catalogs</a><br/> 可以在 WWDC23 這個影片中 <a href="https://developer.apple.com/videos/play/wwdc2023/10165">What’s new in Xcode 15</a> 查看這段 <a href="https://developer.apple.com/videos/play/wwdc2023/10165/?time=270">Meet string catalogs</a>。</p></blockquote><p>設定起來其實非常簡單，大致分為兩個部分：</p><ol><li>在 <code>專案 &gt; Project &gt; Info &gt; Localizations</code> 這裡新增你想要支援的語言</li><li>先新建一個 <code>String Catalog</code> 的檔案，接著在程式碼中要支援多國語系的 String 改成這樣，當你編譯 <code>(⌘ + B)</code> 成功後就會在檔案裡自動出現你所有設定的 String 了</li></ol><pre><code><span class="type">String</span>(localized: <span class="string">"Hello World!"</span>)
</code></pre><h3>跑 Simulator 時更方便的測試不同語言</h3><blockquote><p>參考 <a href="https://twitter.com/sarunw">@sarunw</a> 的這篇文章 <a href="https://sarunw.com/posts/how-to-test-apps-in-other-languages-with-xcode-scheme/">How to quickly test apps in other languages with an Xcode scheme</a><br/> 可以追蹤他的 X ( 原 Twitter ) 時常會有一些開發時小技巧的分享 👉🏻 <a href="https://twitter.com/sarunw">@sarunw</a></p></blockquote><p>在 Xcode 上方點選 Scheme（ ^ + 0）並複製一份，然後在編輯這個 Scheme 的畫面中找到 <code>Run &gt; Options &gt; App Language</code> 設定好語言，接著跑起來 <code>(⌘ + R)</code> 的時候就會依你這個 Scheme 設定的語言啟動 App了。</p><h2>本地端資料儲存</h2><blockquote><p>參考 <a href="https://twitter.com/sarunw">@sarunw</a> 的這篇文章 <a href="https://sarunw.com/posts/url-type-properties/">Better way to get paths to system directories in iOS 16</a></p></blockquote><p>因為 Apple 為了確保執行階段的安全性，所以 iOS App 的環境是基於 Sandbox 的機制去實現的，所以每個 App 都有自己獨立的資料存儲目錄不會跟其它 App 打架。</p><p>所以這邊我們使用 FileManager 取得 url，這邊也提供在 iOS16 以後提供更簡單的方式取得目錄，取得目錄之後就要設定好我們的檔名以及副檔名，這邊我的檔案是 <code>todo</code> 副檔名是 <code>json</code>。</p><pre><code><span class="comment">// 常見取得 url 的方式</span>
<span class="keyword">let</span> documentsDirectory = <span class="keyword">try</span>? <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">url</span>(for: .<span class="dotAccess">documentDirectory</span>, in: .<span class="dotAccess">userDomainMask</span>, appropriateFor: <span class="keyword">nil</span>, create: <span class="keyword">false</span>)

<span class="comment">// iOS16 以後可以用更簡單的方式</span>
<span class="keyword">let</span> documentsDirectory = <span class="type">URL</span>.<span class="property">documentsDirectory</span>

<span class="comment">// 設定檔名以及副檔名</span>
<span class="keyword">let</span> documentURL = directoryURL.<span class="call">appending</span>(components: <span class="string">"todo"</span>).<span class="call">appendingPathExtension</span>(<span class="string">"json"</span>)
</code></pre><img src="https://vickcoo.github.io/images/SimpleToDoAppRecord/UrlDocumentDirectory.png" alt="UrlDocumentDirectory"/><div class="caption">directory</div><p>接著就是使用 <code>JSONEncoder</code> 將資料 encode 為 json 的資料，這邊要注意的是要可以 encode 跟 decode 的話，不管你是用 Struct 或 Class 都需要遵循 <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types">Codable</a> 這個 Protocol，否則 Xcode 就會報錯給你看了。</p><pre><code><span class="comment">// let items: [ToDoItem]</span>

<span class="keyword">func</span> save() {
    <span class="keyword">let</span> directoryURL = <span class="type">URL</span>.<span class="property">documentsDirectory</span>
    <span class="keyword">let</span> documentURL = directoryURL.<span class="call">appending</span>(components: <span class="string">"todo"</span>).<span class="call">appendingPathExtension</span>(<span class="string">"json"</span>)

    <span class="keyword">let</span> jsonEncoder = <span class="type">JSONEncoder</span>()
    <span class="keyword">let</span> data = <span class="keyword">try</span>? jsonEncoder.<span class="call">encode</span>(items)
    <span class="keyword">do</span> {
        <span class="keyword">try</span> data?.<span class="call">write</span>(to: documentURL)
    } <span class="keyword">catch</span> {
        logger.<span class="call">error</span>(<span class="string">"Couldn't write data of toDoItems to:</span> \(documentURL.<span class="property">absoluteString</span>)<span class="string">"</span>)
    }
}
</code></pre><p><code>jsonDecoder.decode</code> 第一個參數要給的是資料的型別，因為我要儲存的資料是用陣列，所以會使用 <code>Array&lt;YourDataType&gt;.self</code>注後最後有一個 <code>completed()</code> 是提供外部呼叫並且資料載入完成後，利用傳入 Closure 來更新畫面中的資料。</p><pre><code><span class="comment">// struct ToDoItem {}</span>

<span class="keyword">func</span> load(completed: <span class="keyword">@escaping</span> () -&gt; ()) {
    <span class="keyword">let</span> directoryURL = <span class="type">URL</span>.<span class="property">documentsDirectory</span>
    <span class="keyword">let</span> documentURL = directoryURL.<span class="call">appending</span>(components: <span class="string">"todo"</span>).<span class="call">appendingPathExtension</span>(<span class="string">"json"</span>)

    <span class="keyword">let</span> jsonDecoder = <span class="type">JSONDecoder</span>()
    <span class="keyword">guard let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: documentURL) <span class="keyword">else</span> { <span class="keyword">return</span> }
    <span class="keyword">do</span> {
        <span class="keyword">try</span> items = jsonDecoder.<span class="call">decode</span>(<span class="type">Array</span>&lt;<span class="type">ToDoItem</span>&gt;.<span class="keyword">self</span>, from: data)
    } <span class="keyword">catch</span> {
        logger.<span class="call">error</span>(<span class="string">"Couldn't load data of toDoItems from:</span> \(documentURL.<span class="property">absoluteString</span>)<span class="string">"</span>)
    }
    <span class="call">completed</span>()
}
</code></pre><h2>NotificationCenter 監聽事件</h2><p>在 Swift 中你如果要監聽（又稱觀察 Observe）某些事件就會需要使用 <a href="https://developer.apple.com/documentation/foundation/notificationcenter">NotificationCenter</a>，例如鍵盤按鈕 Return 鍵、TextField 裡的文字發生變化等等。</p><p>新增要監聽的事件我們使用 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1415360-addobserver">addObserver</a> 要給出四個參數：</p><ul><li>observer：事件觸發要執行 Function 在哪個物件</li><li>selector：事件觸發要執行的 Function</li><li>name：監聽哪個事件</li><li>object：查了文件還是看不太懂，目前是使用 <code>nil</code></li></ul><pre><code><span class="comment">// addObserver 所需參數</span>
<span class="keyword">func</span> addObserver(
    <span class="keyword">_</span> observer: <span class="type">Any</span>,
    selector aSelector: <span class="type">Selector</span>,
    name aName: <span class="type">NSNotification</span>.<span class="type">Name</span>?,
    object anObject: <span class="type">Any</span>?
)

<span class="comment">// 實際呼叫 `addObserver` 的例子</span>
<span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">addObserver</span>(<span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(adjustForKeyboard), name: <span class="type">UIResponder</span>.<span class="property">keyboardWillChangeFrameNotification</span>, object: <span class="keyword">nil</span>)
</code></pre><p>刪除原本新增要監聽的事件則是使用 <code>removeObserver</code>。</p><pre><code><span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">removeObserver</span>(<span class="keyword">self</span>, name: <span class="type">UIResponder</span>.<span class="property">keyboardWillChangeFrameNotification</span>, object: <span class="keyword">nil</span>)
</code></pre><h2>鍵盤處理</h2><p>這裡可以處理的也很多，主要也是提升使用者體驗。</p><h3>彈出鍵盤</h3><p>首先進新增待辨項目的頁面，就代表十之八九是要輸入資料吧？所以可以貼心的將輸入的焦點在標題欄（例子中是用<code>titleTextField</code>）並且直接彈出鍵盤，讓使用者打開畫面就可以直接輸入文字，而不用再多點擊一下輸入框才能輸入文字。</p><pre><code>titleTextField.<span class="call">becomeFirstResponder</span>()
</code></pre><h3>文字輸入框被鍵盤擋住</h3><blockquote><p>參考 <a href="https://twitter.com/twostraws">@Paul Husdon</a> 的這篇文章 <a href="https://www.hackingwithswift.com/read/19/7/fixing-the-keyboard-notificationcenter">Fixing the keyboard: NotificationCenter</a><br/> 如果不知道怎麼開始學習開發 iOS App 可以到他的網站 <a href="https://www.hackingwithswift.com/read">Hacking With Swift</a> 有一系列的入門教學，影片文字的版本都有！</p></blockquote><p>需要利用前面說的 NotificationCenter 來監聽鍵盤的事件：</p><ul><li><code>keyboardWillChangeFrameNotification</code> 可以監聽鍵盤的顯示、隱藏、旋轉方向等等</li><li><code>keyboardWillHideNotification</code> 會需要使用這個事件，這邊是參考 <a href="https://twitter.com/twostraws">Paul Husdon</a> 的<a href="https://www.hackingwithswift.com/read/19/7/fixing-the-keyboard-notificationcenter">文章</a>，<em>意思是說他測試時發現 <code>keyboardWillChangeFrameNotification</code> 不足以捕獲到硬體鍵盤連接</em></li></ul><pre><code><span class="keyword">let</span> notificationCenter = <span class="type">NotificationCenter</span>.<span class="property">default</span>
notificationCenter.<span class="call">addObserver</span>(<span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(adjustForKeyboard), name: <span class="type">UIResponder</span>.<span class="property">keyboardWillHideNotification</span>, object: <span class="keyword">nil</span>)
notificationCenter.<span class="call">addObserver</span>(<span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(adjustForKeyboard), name: <span class="type">UIResponder</span>.<span class="property">keyboardWillChangeFrameNotification</span>, object: <span class="keyword">nil</span>)
</code></pre><p>接著就是要在事件觸發後處理輸入框被遮擋的問題，<code>keyboardFrameEndUserInfoKey</code></p><p>設定 <code>noteTextView</code> 的 <code>contentInset</code> 代表會將 <code>noteTextView</code> 的底部往上推我指指定的距離，設定為 <code>.zero</code> 就是改回預設值</p><p><code>scrollIndicatorInsets</code> 的原理也一樣，只不過是變成設定旁邊顯示的 Scroll Bar。</p><pre><code><span class="comment">// @IBOutlet var noteTextView: TextView!</span>

<span class="keyword">@objc func</span> adjustForKeyboard(<span class="keyword">_</span> notification: <span class="type">Notification</span>) {
    <span class="keyword">guard let</span> keyboardValue = notification.<span class="property">userInfo</span>?[<span class="type">UIResponder</span>.<span class="property">keyboardFrameEndUserInfoKey</span>] <span class="keyword">as</span>? <span class="type">NSValue</span> <span class="keyword">else</span> { <span class="keyword">return</span> }

    <span class="keyword">let</span> keyboardScreenEndFrame = keyboardValue.<span class="property">cgRectValue</span>
    <span class="keyword">let</span> keyboardViewEndFrame = view.<span class="call">convert</span>(keyboardScreenEndFrame, from: view.<span class="property">window</span>)

    <span class="keyword">if</span> notification.<span class="property">name</span> == <span class="type">UIResponder</span>.<span class="property">keyboardWillHideNotification</span> {
        noteTextView.<span class="property">contentInset</span> = .<span class="dotAccess">zero</span>
    } <span class="keyword">else</span> {
        noteTextView.<span class="property">contentInset</span> = <span class="type">UIEdgeInsets</span>(top: <span class="number">0</span>, left: <span class="number">0</span>, bottom: keyboardViewEndFrame.<span class="property">height</span> - view.<span class="property">safeAreaInsets</span>.<span class="property">bottom</span>, right: <span class="number">0</span>)
    }

    noteTextView.<span class="property">scrollIndicatorInsets</span> = noteTextView.<span class="property">contentInset</span>
    noteTextView.<span class="call">scrollRangeToVisible</span>(noteTextView.<span class="property">selectedRange</span>)
}
</code></pre><h3>隱藏鍵盤: 在鍵盤上方新增按鈕</h3><p>在很多 App 中可以看到鍵盤上方都會有一個<code>完成（Done）</code> 的按鈕，點擊後就會隱藏鍵盤，這是通過一個 <a href="https://developer.apple.com/documentation/uikit/uitoolbar">UIToolBar</a> 來實現。</p><p>這邊 <code>ToolBar</code> 由兩個 Item 組成 <code>doneButton</code> 是主要用來隱藏鍵盤的按鈕，<code>flexSpace</code> 用來填充空白將 <code>doneButton</code> 推到最右邊，接著因為我想讓所有輸入框都能顯示這個按鈕所以利用 <code>inputAccessoryView</code> 來將 ToolBar 設定上去。</p><pre><code><span class="comment">// add a 'Done' button to provide a function for hide keyboard.</span>
<span class="keyword">let</span> toolbar = <span class="type">UIToolbar</span>()
<span class="keyword">let</span> flexSpace = <span class="type">UIBarButtonItem</span>(barButtonSystemItem: .<span class="dotAccess">flexibleSpace</span>, target: <span class="keyword">nil</span>, action: <span class="keyword">nil</span>)
<span class="keyword">let</span> doneButton = <span class="type">UIBarButtonItem</span>(title: <span class="type">String</span>(localized: <span class="string">"Done"</span>), style: .<span class="dotAccess">done</span>, target: <span class="keyword">self</span>, action: <span class="keyword">#selector</span>(hideKeyboardDoneButtonTapped))
toolbar.<span class="call">setItems</span>([flexSpace, doneButton], animated: <span class="keyword">true</span>)
toolbar.<span class="call">sizeToFit</span>()
noteTextView.<span class="property">inputAccessoryView</span> = toolbar
titleTextField.<span class="property">inputAccessoryView</span> = toolbar
</code></pre><h3>隱藏鍵盤: 點擊畫面其餘空白部分</h3><p>新增點擊手勢來隱藏鍵盤。</p><pre><code><span class="comment">// Hide keyboard when user tapped other position on the view.</span>
<span class="keyword">let</span> tap = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>.<span class="property">view</span>, action: <span class="keyword">#selector</span>(<span class="type">UIView</span>.<span class="call">endEditing</span>(<span class="keyword">_</span>:)))
<span class="keyword">self</span>.<span class="property">view</span>.<span class="call">addGestureRecognizer</span>(tap)
</code></pre><h2>發送通知</h2><blockquote><p>這裡的通知跟 NotificationCenter 是不一樣的東西，請不要搞混哦！</p></blockquote><p>這裡的範例都是使用本地端發送通知，要 <code>import UserNotifications</code>，組成通知主要分成三個部分： <em> Content 內容 </em> Trigger 觸發方式 * Request 請求發送通知</p><p>首先要建立一個 Content 也就是通知所要發出的內容，使用 <a href="https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent">UNMutableNotificationContent</a>。</p><pre><code><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()
content.<span class="property">title</span> = <span class="string">"標題"</span>
content.<span class="property">subtitle</span> = <span class="string">"副標題"</span>
content.<span class="property">body</span> = <span class="string">"內容"</span>
content.<span class="property">badge</span> = <span class="keyword">nil</span>
content.<span class="property">sound</span> = .<span class="dotAccess">default</span>
</code></pre><p>接著 <a href="https://developer.apple.com/documentation/usernotifications/unnotificationtrigger">Trigger</a> 有四種可以選擇，我們使用 <a href="https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger">UNCalendarNotificationTrigger</a> 在指定的日期時間發送通知](https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent)。</p><pre><code><span class="keyword">var</span> dateComponent = <span class="type">Calendar</span>.<span class="property">current</span>.<span class="call">dateComponents</span>([.<span class="dotAccess">year</span>, .<span class="dotAccess">month</span>, .<span class="dotAccess">day</span>, .<span class="dotAccess">hour</span>, .<span class="dotAccess">minute</span>], from: <span class="type">Date</span>())
<span class="keyword">let</span> trigger = <span class="type">UNCalendarNotificationTrigger</span>(dateMatching: dateComponent, repeats: <span class="keyword">false</span>)
</code></pre><p>最後將前面的 <code>Content</code> 跟 <code>Trigger</code> 組合起來成 <a href="https://developer.apple.com/documentation/usernotifications/unnotificationrequest">UNNotificationRequest</a>。</p><pre><code><span class="comment">// 將 Content 跟 Trigger 組成 Request</span>
<span class="keyword">let</span> notificationID = <span class="type">UUID</span>().<span class="property">uuidString</span>
<span class="keyword">let</span> request = <span class="type">UNNotificationRequest</span>(identifier: notificationID, content: content, trigger: trigger)

<span class="comment">// 將通知加入排程，並且加入錯誤處理</span>
<span class="type">UNUserNotificationCenter</span>.<span class="call">current</span>().<span class="call">add</span>(request) { error <span class="keyword">in
    if let</span> error = error {
        <span class="call">print</span>(<span class="string">"</span>\(error.<span class="property">localizedDescription</span>)<span class="string">"</span>)
    }
}
</code></pre><h2>轉跳到系統的設定 App</h2><p>當使用者安裝完 App 後，你向他們請求發送通知的權限但是被拒絕了，然後某他使用者用到的某些功能必須要有通知權限才能執行，這時候提供一個簡單的方法讓使用者可以點一下就可以跳到設定 App 是不是會讓他們更願意去給予權限。</p><p>那要如何達成呢？主要核心就兩行而已，第一個是取得在你的 App 在<strong>設定</strong>中的 URL，第二個就是跳轉到那裡去！</p><pre><code><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="type">UIApplication</span>.<span class="property">openSettingsURLString</span>)!
<span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="call">open</span>(url)
</code></pre><h2>利用 Button 實現 CheckBox 功能</h2><p>因為這篇文章是說明 ToDo App 理所當然會希望會有一個簡單的 CheckBox 來讓使用者點擊完成待辨項目。 所以我們會需要建立好一個 UIButton 後，在 Attributes Inspector 中把 Type 改成 Custom，接著把 Image 設定為 <code>square</code>（這裡使用的是 SF Symbol），然後在把 State Config 改成 Selected 後再把 Image 設定為 <code>checkmark.square</code>，記得也要把裡面的文字清空哦。</p><p>這裡做的事就是把 Button 設定兩個<strong>不同狀態下要顯示的</strong> Image，<code>square</code> 代表著未被勾選的框，<code>checkmark.square</code> 則代表已勾選的框。</p><p>設定完之後點擊 Button 並不會發生任何改變，因為我們只是先設定好它在什麼狀態要呈現的樣子而已，所以我們要在點擊按鈕的時候去做處理。</p><pre><code><span class="comment">// 勾選，顯示 `checkmark.square` 的 Image</span>
checkButton.<span class="property">isSelected</span> = <span class="keyword">true</span>

<span class="comment">// 未勾選，顯示 `square` 的 Image</span>
checkButton.<span class="property">isSelected</span> = <span class="keyword">false</span>
</code></pre><p>最後這個也很重要！因為在我的 App 中這個自訂的 Button 是放在 Cell 中，所以我們要如何知道使用者目前點擊的 Cell 的 IndexPath 這是一個問題，你可能會問不就使用 <code>tableView.indexPathForSelectedRow</code> 就可以了嗎，但是注意我們是點擊 Cell 裡的 Button 所以並不會更新 <code>indexPathForSelectedRow</code>，所以提供了另一個解決方案，就是使用 <code>indexPath</code> 只要向它傳入你目前點擊的 Cell 就可以取得 IndexPath。</p><pre><code><span class="comment">// @IBOutlet var tableView: UITableView!
// func indexPath(for cell: UITableViewCell) -&gt; IndexPath?</span>

tableView.<span class="call">indexPath</span>(for: cell)
</code></pre><h2>後記</h2><p>實際上寫這篇文章應該比我開發的時間還多，邊寫的時候也會發現好像還有很多不懂的細節，不過這就是分享的優點吧！讓自己確認有沒有什麼還不夠瞭解的部分，又能分享出去讓有需要的人知道。</p><p>因為全部寫在一篇裡內容太過長，所以省略了很多比較細的內容，如果有需要可以到 Github：<a href="https://github.com/vickcoo/odot">vickcoo/odot</a> 上看原始碼，有什麼更好的做法或是有問題的地方都可以留言或是透過其他方式告訴我。</p><ul><li>Email: <a href="mailto:cwk91405133@gmail.com">cwk91405133@gmail.com</a></li></ul><ul><li>X: <a href="https://x.com/vickcoo">@vickcoo</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://vickcoo.github.io/posts/Intro-ARC%5Ben%5D</guid><title>Leave Memory Troubles to ARC</title><description>In Swift, ARC is an essential concept responsible for memory management, ensuring that objects no longer in use are properly released. This article will provide a detailed explanation of how ARC works and how to avoid common memory leak issues.</description><link>https://vickcoo.github.io/posts/Intro-ARC%5Ben%5D</link><pubDate>Wed, 25 Oct 2023 11:26:00 +0800</pubDate><content:encoded><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Automatic_Reference_Counting">Automatic Reference Counting</a>, abbreviated as <strong>ARC</strong>, is a key feature of the Swift programming language. It is responsible for managing the lifecycle of objects in memory to ensure efficient allocation and deallocation of memory resources. ARC works automatically and lets you even do not manually manage memory, reducing the risks of memory leaks and improper deallocation.</p><ul><li>Swift automatically manages memory and does not need manual intervention. However, you should consider the relationships between objects to prevent memory leaks.</li><li>Every time an instance of a class is created, ARC allocates memory to store all the data about that instance.</li><li>ARC automatically releases objects in memory when their lifetime ends.</li></ul><h2>How ARC Works</h2><p>Its operation is simple. When an object is created, its ARC is initialized to 1. When new references point to this object, the ARC is incremented by 1. When a reference no longer exists, the ARC is decremented by 1. It's a straightforward addition and subtraction!</p><p>Let's explain this in two different ways:</p><h3>Text Version</h3><p>One day, David was walking down the street and saw a shiny <code>iPhone XR</code>. He was attracted to its features and appearance, so he decided to take it and became its owner. At this point, because David referenced the <code>iPhone XR</code>, the iPhone's ARC increased to 2.</p><p>After a while, John also walked by and saw the <code>iPhone XR</code>. He claimed that the phone belonged to him and requested it from David. Now, the iPhone's ARC became 3.</p><p>However, this situation didn't last long. Shortly after, a police officer appeared, investigated the phone's origin, and found out that the iPhone didn't belong to David or John. They were both informed that they couldn't possess the phone because it didn't belong to either of them. As a result, both David and John canceled their references to the iPhone, and the ARC quickly decreased to 1.</p><p>Finally, since no one knew who the phone belonged to, it was decided to be destroyed, and the <code>iPhone XR</code> also canceled its reference to the iPhone. So, the ARC became zero, and it disappeared from the world (released from memory).</p><h3>Code Version</h3><p>The classes <code>Phone</code> and <code>Person</code> used in the story can be found in the following code:</p><pre><code><span class="comment">// One day, David was walking down the street and saw a shiny `iPhone XR`. He was attracted to its features and appearance, so he decided to take it and became its owner. At this point, because David referenced the `iPhone XR`, the iPhone's ARC increased to 2.</span>
<span class="keyword">var</span> iPhone: <span class="type">Phone</span>? = <span class="type">Phone</span>(name: <span class="string">"iPhone XR"</span>) <span class="comment">// ARC = 1</span>
<span class="keyword">var</span> david: <span class="type">Person</span> = <span class="type">Person</span>(name: <span class="string">"David"</span>)
david.<span class="property">phone</span> = iPhone <span class="comment">// ARC = 2

// After a while, John also walked by and saw the `iPhone XR`. He claimed that the phone belonged to him and requested it from David. Now, the iPhone's ARC became 3.</span>
<span class="keyword">var</span> john: <span class="type">Person</span> = <span class="type">Person</span>(name: <span class="string">"John"</span>)
john.<span class="property">phone</span> = iPhone <span class="comment">// ARC = 3

// However, this situation didn't last long. Shortly after, a police officer appeared, investigated the phone's origin, and found out that the iPhone didn't belong to David or John. They were both informed that they couldn't possess the phone because it didn't belong to either of them. As a result, both David and John canceled their references to the iPhone, and the ARC quickly decreased to 1.</span>
david.<span class="property">phone</span> = <span class="keyword">nil</span> <span class="comment">// ARC = 2</span>
john.<span class="property">phone</span> = <span class="keyword">nil</span> <span class="comment">// ARC = 1

// Finally, since no one knew who the phone belonged to, it was decided to be destroyed, and the `iPhone XR` also canceled its reference to the iPhone. So, the ARC became zero, and it disappeared from the world (released from memory).</span>
iPhone = <span class="keyword">nil</span> <span class="comment">// ARC = 0</span>
</code></pre><pre><code><span class="keyword">class</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> phone: <span class="type">Phone</span>?
    <span class="keyword">init</span> (name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}

<span class="keyword">class</span> Phone {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">init</span>(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}
</code></pre><h2>What is a Retain Cycle, and How Does It Happen?</h2><p>A Retain Cycle refers to an object existing in memory without a way to be released. It occurs when two objects strong reference each other. The following examples explain this.</p><h3>Story Version</h3><p>In a distant universe, two stars existed. They attracted each other, as if destined to shine together, but their meeting was not as simple as it seemed.</p><p>My girlfriend and I loved stargazing, and one day, we found two incredibly beautiful stars. We decided to make them ours and named them <code>Shelly</code> and <code>Ben</code>. These two stars attracted each other, creating a mysterious connection, much like a romantic relationship. They established an invisible link in the universe, combining their radiance.</p><p>One day, my girlfriend and I lost interest in stargazing and decided to disconnect from those stars. However, the radiance of the stars didn't disappear. This happened because these two stars had formed a strong bond, leaving a faint line of radiance in the universe, causing them to reference each other.</p><p>Even though we no longer observed these stars and couldn't find them, their radiance continued to exist because ARC maintained their existence. They would shine forever in the universe, unable to be referenced, much like old lovers who could never meet again.</p><p>This story reflects how Automatic Reference Counting (ARC) operates. Even when the reference relationship between objects is severed, if ARC still holds references to them, they will persist, unable to be deallocated. ARC ensures correct memory management but reminds us to handle references carefully to avoid unexpected situations.</p><h3>Code Version</h3><p>The classes <code>Star</code> and <code>Person</code> used in the story can be found in the following code:</p><pre><code><span class="keyword">var</span> me: <span class="type">Person</span> = <span class="type">Person</span>(name: <span class="string">"me"</span>)
<span class="keyword">var</span> girlfriend: <span class="type">Person</span> = <span class="type">Person</span>(name: <span class="string">"girlfriend"</span>)
<span class="comment">// We loved stargazing, and one day, we found two incredibly beautiful stars, and we decided to make them ours and named them `Shelly` and `Ben`</span>
var shelly: <span class="type">Star</span> = <span class="type">Star</span>(name: <span class="string">"Shelly"</span>) <span class="comment">// shelly ARC = 1</span>
<span class="keyword">var</span> ben: <span class="type">Star</span> = <span class="type">Star</span>(name: <span class="string">"Ben"</span>) <span class="comment">// ben ARC = 1</span>

me.<span class="property">star</span> = ben
girlfriend.<span class="property">star</span> = shelly

<span class="comment">// These two stars attracted each other, creating a mysterious connection, much like a romantic relationship. They established an invisible link in the universe, combining their radiance.</span>
ben.<span class="property">linkStar</span> = shelly <span class="comment">// ben ARC = 2</span>
shelly.<span class="property">linkStar</span> = ben <span class="comment">// shelly ARC = 2

// One day, my girlfriend and I lost interest in stargazing and decided to disconnect from those stars.</span>
me.<span class="property">star</span> = <span class="keyword">nil</span> <span class="comment">// ben ARC = 1</span>
girlfriend.<span class="property">star</span> = <span class="keyword">nil</span> <span class="comment">// shelly ARC = 1

// However, the radiance of the stars didn't disappear. This happened because these two stars had formed a strong bond, leaving a faint line of radiance in the universe, causing them to reference each other.
// Even though we no longer observed these stars and couldn't find them, their radiance continued to exist because ARC maintained their existence. They would shine forever in the universe, unable to be referenced, much like old lovers who could never meet again.
// This story illustrates the operation of Automatic Reference Counting (ARC). Even when the reference relationships between objects have been severed, if ARC still holds references to them, they will continue to exist, unable to be deallocated. ARC ensures proper memory management but also reminds us to handle references carefully to prevent unexpected situations.</span>
</code></pre><pre><code><span class="keyword">class</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> star: <span class="type">Star</span>?
    <span class="keyword">init</span>(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}

<span class="keyword">class</span> Star {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> linkStar: <span class="type">Star</span>?
    <span class="keyword">init</span>(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}
</code></pre><h2>How to Avoid Memory Leaks</h2><p>As mentioned earlier, a Retain Cycle can lead to Memory Leaks.</p><ul><li>A Retain Cycle occurs with strong references between two objects.</li><li>A Memory Leak happens when an object exists in memory, but the program can't access it or release it.</li></ul><p>To avoid these issues, two keywords come to the rescue. Both methods involve preventing the object from being counted in the ARC:</p><p>The first one is <strong>weak</strong>. You can use it by adding <code>weak</code> in front of the variable declaration, like this:</p><pre><code><span class="keyword">weak var</span> star: <span class="type">Star</span>?
</code></pre><p>The second one is <strong>unowned</strong>. It is similar to <code>weak</code> but without the optionality. You can use it when you're sure that the object won't become <code>nil</code> before its lifecycle ends:</p><pre><code><span class="keyword">unowned var</span> star: <span class="type">Star</span>
</code></pre><p>In summary:</p><ul><li>Use <code>weak</code> with <code>optional</code> variables.</li><li>Use <code>unowned</code> with <code>non-optional</code> variables.</li></ul><h2>Reference</h2><ul><li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/">The Swift Programming Language (5.9) - Automatic Reference Counting</a></li><li><a href="https://chunyili200556.medium.com/">ChunYi LI</a> 的 <a href="https://medium.com/one-two-swift/arc-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-weak-unowned-b3f5ae4239c7">Swift基礎 — ARC 記憶體管理Weak 、Unowned</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://vickcoo.github.io/posts/Intro-ARC%5Bzh-TW%5D</guid><title>將記憶體煩惱留給ARC</title><description>在Swift中，ARC是一個重要的概念，它負責管理記憶體，確保不再使用的物件能夠被正確釋放。本文將詳細解釋ARC的工作原理，以及如何避免常見的記憶體洩漏問題。</description><link>https://vickcoo.github.io/posts/Intro-ARC%5Bzh-TW%5D</link><pubDate>Wed, 25 Oct 2023 11:26:00 +0800</pubDate><content:encoded><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">自動引用計數</a>（Automatic Reference Counting，簡稱<strong>ARC</strong>）是Swift語言的一個關鍵功能，它負責管理物件在記憶體中的生命週期，以確保記憶體資源能夠被有效地分配和釋放。ARC是Swift的一個重要特性，使開發者無需手動管理記憶體，從而減少了記憶體洩漏和釋放不當的風險。</p><ul><li>Swift會用它自動管理記憶體，無需我們手動操作，但你確實要考慮物件之間的關係以避免記憶體洩漏（Memory Leak）</li><li>每次建立一個類別的實例時，ARC會分配一塊記憶體來儲存關於這個實例的所有資料</li><li>ARC會在Lifetime結束時自動釋放（deallocate）記憶體中的物件</li></ul><h2>ARC工作原理</h2><p>它的運作方式很簡單，當有一個物件被創立的時候，它的ARC會初始化為1，當有新的引用指向這個物件時就會加1，當一個引用不再存在時ARC就會減1，很簡單的加減法吧！</p><p>這邊用兩種方式寫個故事幫助你們瞭解</p><h3>文字版</h3><p>有一天，David走在路上，看到了閃亮的<code>iPhone XR</code>。他被它的功能和外觀所吸引，決定拿走了它並成為了它的持有者。這個時候，因為David引用了<code>iPhone XR</code>iPhone的ARC增加到2。</p><p>過了一會，John也走過來，他看到了這支<code>iPhone XR</code>，並說這支手機是他的，因此他要求對方將它交給John。現在，iPhone的ARC變成了3。</p><p>然而，這個情況並不持久。不久後，一位警察出現，調查了手機的來源，發現這支iPhone根本不屬於David或John。他們兩人被告知不能再持有這支手機，因為它並不屬於他們中的任何一個。於是，David和John都取消了對iPhone的引用，ARC迅速降為1。</p><p>最後也不知道這支手機是誰的，所以決定進行銷毀，<code>iPhone XR</code>也取消了對iPhone的引用，所以ARC歸零從此就消失在這個世界上(從記憶體中釋放)。</p><h3>程式碼版</h3><p>故事中用到的<code>Phone</code>跟<code>Person</code>的類別可以至下一段程式碼查看</p><pre><code><span class="comment">//有一天，David走在路上，看到了閃亮的`iPhone XR`。他被它的功能和外觀所吸引，決定拿走了它並成為了它的持有者。這個時候，因為David引用了`iPhone XR`iPhone的ARC增加到2。</span>
<span class="keyword">var</span> iPhone: <span class="type">Phone</span>? = <span class="type">Phone</span>(name: <span class="string">"iPhone XR"</span>) <span class="comment">// ARC = 1</span>
<span class="keyword">var</span> david: <span class="type">Person</span> = <span class="type">Person</span>(name: <span class="string">"David"</span>)
david.<span class="property">phone</span> = iPhone <span class="comment">// ARC = 2

//過了一會，John也走過來，他看到了這支`iPhone XR`，並說這支手機是他的，因此他要求對方將它交給John。現在，iPhone的ARC變成了3。</span>
<span class="keyword">var</span> john: <span class="type">Person</span> = <span class="type">Person</span>(name: <span class="string">"John"</span>)
john.<span class="property">phone</span> = iPhone <span class="comment">// ARC = 3

//然而，這個情況並不持久。不久後，一位警察出現，調查了手機的來源，發現這支iPhone根本不屬於David或John。他們兩人被告知不能再持有這支手機，因為它並不屬於他們中的任何一個。於是，David和John都取消了對iPhone的引用，ARC迅速降為1。</span>
david.<span class="property">phone</span> = <span class="keyword">nil</span> <span class="comment">// ARC = 2</span>
john.<span class="property">phone</span> = <span class="keyword">nil</span> <span class="comment">// ARC = 1

//最後也不知道這支手機是誰的，所以決定進行銷毀，`iPhone XR`也取消了對iPhone的引用，所以ARC歸零從此就消失在這個世界上(從記憶體中釋放)。</span>
iPhone = <span class="keyword">nil</span> <span class="comment">// ARC = 0</span>
</code></pre><pre><code><span class="keyword">class</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> phone: <span class="type">Phone</span>?
    <span class="keyword">init</span> (name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}

<span class="keyword">class</span> Phone {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">init</span>(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}
</code></pre><h2>Retain Cycle是什麼，怎麼發生的?</h2><p>Retain Cycle就是指物件存在記憶體中，但是不知道什麼原因所以無法被釋放。 當兩個物件互相引用時就有可能會發生Retain Cycle，以下面的例子來說明好了，可以邊看邊對照。</p><h3>故事版</h3><p>在遙遠的宇宙中，有兩顆星星。這兩顆星星互相吸引，彷彿注定要一起閃耀，但他們的相遇並不如表面上看起來那麼簡單。</p><p>我跟女朋友很喜歡觀星，有天我們找到兩顆超漂亮的星星，我們決定把它們變成我們的並且取名為<code>Shelly</code>跟<code>Ben</code>，這兩顆星星互相吸引，我感覺它們有某種連結就像是對情侶，所以他們在宇宙中建立了一條神秘的聯繫，這就像是將他們的光芒結合在一起。</p><p>某一天我跟女朋友已經不喜歡觀星了，決定不再管那些星星，斷開我們跟星星之間的結繫，但星星的光芒並沒有消失。這是因為這兩顆星星在彼此間建立了強大的連結，就像他們在宇宙中留下了一條微弱的光芒之線，使它們互相引用。</p><p>儘管我們不再觀察這些星星也找不到它們，但這些光芒仍然存在，因為ARC保持著它們的存在。它們將永遠閃耀在宇宙中，無法再被引用，就像永遠無法再見面的舊情人。</p><p>這個故事反映了ARC的運作原理。即使物件之間的引用關係已經斷開，但當ARC還保持對它們的引用時，它們將繼續存在，無法被釋放。ARC確保了記憶體的正確管理，但也提醒我們要謹慎處理引用，以避免出現意外的情況。</p><h3>程式碼版</h3><p>故事中用到的<code>Star</code>跟<code>Person</code>的類別可以至下一段程式碼查看</p><pre><code><span class="keyword">var</span> me: <span class="type">Person</span> = <span class="type">Person</span>(name: <span class="string">"me"</span>)
<span class="keyword">var</span> girlfriend: <span class="type">Person</span> = <span class="type">Person</span>(name: <span class="string">"girlfriend"</span>)
<span class="comment">// 我跟女朋友很喜歡觀星，有天我們各自找到超漂亮的星星，我們決定把那些星星變成我們的並且取名為`Shelly`跟`Ben`</span>
var shelly: <span class="type">Star</span> = <span class="type">Star</span>(name: <span class="string">"Shelly"</span>) <span class="comment">// shelly ARC = 1</span>
<span class="keyword">var</span> ben: <span class="type">Star</span> = <span class="type">Star</span>(name: <span class="string">"Ben"</span>) <span class="comment">// ben ARC = 1</span>

me.<span class="property">star</span> = ben
girlfriend.<span class="property">star</span> = shelly

<span class="comment">// 這兩顆星星互相吸引，我感覺它們有某種連結就像是對情侶，所以他們在宇宙中建立了一條神秘的聯繫，這就像是將他們的光芒結合在一起。</span>
ben.<span class="property">linkStar</span> = shelly <span class="comment">// ben ARC = 2</span>
shelly.<span class="property">linkStar</span> = ben <span class="comment">// shelly ARC = 2

// 某一天我跟女朋友已經不喜歡觀星了，決定不再管那些星星，斷開我們跟星星之間的結繫</span>
me.<span class="property">star</span> = <span class="keyword">nil</span> <span class="comment">// ben ARC = 1</span>
girlfriend.<span class="property">star</span> = <span class="keyword">nil</span> <span class="comment">// shelly ARC = 1

// 但星星的光芒並沒有消失。這是因為這兩顆星星在彼此間建立了強大的連結，就像他們在宇宙中留下了一條微弱的光芒之線，使它們互相引用。
// 儘管我們不再觀察這些星星也找不到它們，但這些光芒仍然存在，因為ARC保持著它們的存在。它們將永遠閃耀在宇宙中，無法再被引用，就像永遠無法再見面的舊情人。
// 這個故事反映了自動引用計數（ARC）的運作原理。即使物件之間的引用關係已經斷開，但當ARC還保持對它們的引用時，它們將繼續存在，無法被釋放。ARC確保了記憶體的正確管理，但也提醒我們要謹慎處理引用，以避免出現意外的情況。</span>
</code></pre><pre><code><span class="keyword">class</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> star: <span class="type">Star</span>?
    <span class="keyword">init</span>(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}

<span class="keyword">class</span> Star {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> linkStar: <span class="type">Star</span>?
    <span class="keyword">init</span>(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}
</code></pre><h2>如何避免Memory Leak</h2><p>前面說的Retain Cycle就可能會造成Memory Leak</p><ul><li>Retain Cycle就是兩物件之間強引用（Strong Reference）</li><li>Memory Leak就是物件存在記憶體中，但是程式已經存取不到也無法釋放</li></ul><p>這邊要介紹兩個Keyword來解決問題，這兩個方法的核心原理都是這個物件不會加入ARC進行計數， 第一個是<strong>weak</strong>，就在宣告變數的前面加上<code>weak</code>就好了！</p><pre><code><span class="keyword">weak var</span> star: <span class="type">Star</span>?
</code></pre><p>第二個是<strong>unowned</strong>，跟<code>weak</code>差在optional的部分，當你確認這個物件在它生命週期結束前都不會變成<code>nil</code>就可以使用它</p><pre><code><span class="keyword">unowned var</span> star: <span class="type">Star</span>
</code></pre><p>簡單來說</p><ul><li><code>weak</code>用來修飾<code>optional</code></li><li><code>unowned</code>用來修飾<code>non-optional</code></li></ul><h2>Reference</h2><ul><li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/">The Swift Programming Language (5.9) - Automatic Reference Counting</a></li><li><a href="https://chunyili200556.medium.com/">ChunYi LI</a> 的 <a href="https://medium.com/one-two-swift/arc-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-weak-unowned-b3f5ae4239c7">Swift基礎 — ARC 記憶體管理Weak 、Unowned</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://vickcoo.github.io/posts/Swift-Structs-and-Classes-A-Friendly-Guide-to-Their-Differences-and-Similarities%5Ben%5D</guid><title>Swift Structs and Classes: A Friendly Guide to Their Differences and Similarities</title><description>Dive into the world of Swift programming to struct and class and break down similarities and differences</description><link>https://vickcoo.github.io/posts/Swift-Structs-and-Classes-A-Friendly-Guide-to-Their-Differences-and-Similarities%5Ben%5D</link><pubDate>Wed, 20 Sep 2023 10:42:00 +0800</pubDate><content:encoded><![CDATA[<p>When your're delving into the world of Swift programming, you'll inevitably come across two essential concepts: <code>struct</code> and <code>class</code>. In this guide, we'll unravel the mysteries of struct and class, making them easier to understand.</p><h2>Similarities</h2><ul><li>Define properties (that including computed properties &amp; property observer)</li><li>Define method</li><li>Define subscripts to provide access to their value</li><li>Define initializers</li><li>Be extended to expand their functionality beyond a default implementation</li><li>These have the ability to conform to protocols and then provide functionality</li></ul><h2>Differences</h2><p>class have adiitional capabilities that structure don't have.</p><ul><li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance/">Inheritance</a></li><li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/typecasting/">Type casting</a></li><li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/deinitialization/">Deinitializers</a></li><li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/">ARC(Automatic Reference Counting)</a></li></ul><p>other difference thing.</p><ul><li>Value Type &amp; Reference Type</li><li>Mutable &amp; Immutable</li><li>Memberwise Initializer</li></ul><h2>Syntax</h2><p>this is the least code to define this struct and class, I'll show you actually example later.</p><pre><code><span class="keyword">struct</span> SomeStruct {
}
<span class="keyword">class</span> SomeClass {
}
</code></pre><h2>Value Type &amp; Reference Type</h2><p>Swift struct is Value Type, this means any properties in struct instance, they always copy when they're passed around in your code.</p><pre><code><span class="keyword">struct</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>
}

<span class="keyword">let</span> andrew = <span class="type">Person</span>(name: <span class="string">"Andrew"</span>, age: <span class="number">22</span>)
<span class="keyword">var</span> eric = andrew

eric.<span class="property">age</span> = <span class="number">41</span>

<span class="call">print</span>(andrew.<span class="property">age</span>) <span class="comment">// print: 22</span>
<span class="call">print</span>(eric.<span class="property">age</span>) <span class="comment">// print: 41</span>
</code></pre><p>And class is Reference Type, that aren't copied when they're passed. That reference same instance. For example, similar we defined struct above</p><pre><code><span class="keyword">class</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>

    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
        <span class="keyword">self</span>.<span class="property">age</span> = age
    }
}

<span class="keyword">let</span> andrew = <span class="type">Person</span>(name: <span class="string">"Andrew"</span>, age: <span class="number">22</span>)
<span class="keyword">var</span> eric = andrew

eric.<span class="property">age</span> = <span class="number">41</span>

<span class="call">print</span>(andrew.<span class="property">age</span>) <span class="comment">// print: 41</span>
<span class="call">print</span>(eric.<span class="property">age</span>) <span class="comment">// print: 41</span>
</code></pre><h2>Initializers</h2><p>In Swift, when you create a struct and define properties, struct automatically get a initializer called <em>Memberwise Initializer</em>. but your must manually define a iniitializer in class</p><pre><code><span class="comment">// struct</span>
<span class="keyword">struct</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>
}
<span class="keyword">let</span> leo = <span class="type">Person</span>(name: <span class="string">"Leo"</span>, age: <span class="number">32</span>)

<span class="comment">// class</span>
<span class="keyword">class</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>

    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
        <span class="keyword">self</span>.<span class="property">age</span> = age
    }
}
<span class="keyword">let</span> leo = <span class="type">Person</span>(name: <span class="string">"Leo"</span>, age: <span class="number">32</span>)
</code></pre><h2>Mutating</h2><p>you can't modify any properties insdie method in struct by default, the solution is mark it using <code>mutating</code> keyword, like this:</p><pre><code><span class="keyword">struct</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>

    <span class="keyword">mutating func</span> setName(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}
</code></pre><h2>Reference</h2><ul><li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures">The Swift Programming Language</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://vickcoo.github.io/posts/Swift-Structs-and-Classes-A-Friendly-Guide-to-Their-Differences-and-Similarities%5Bzh-TW%5D</guid><title>Swift Structures &amp; Classes：它們之間的差異和相似之處</title><description>深入Swift程式設計世界，進行Structures和Classes分析相似點和差異</description><link>https://vickcoo.github.io/posts/Swift-Structs-and-Classes-A-Friendly-Guide-to-Their-Differences-and-Similarities%5Bzh-TW%5D</link><pubDate>Wed, 20 Sep 2023 10:42:00 +0800</pubDate><content:encoded><![CDATA[<p>當您深入研究 Swift 程式設計世界時，您將不可避免地遇到兩個基本概念：<code>struct</code>和<code>class</code>。在這篇文章中，我們將揭開它們之間的神秘面紗，使它們更容易理解。</p><h2>相似之處</h2><ul><li>定義屬性(Property)，包含<strong>計算屬性</strong>(Computed Property)跟<strong>屬性觀察器</strong>(Property Observer)</li><li>定義方法(Function)</li><li>定義下標(Subscript)來提供存取資料的方式</li><li>定義建構子(Initializer)</li><li>除了Apple提供的方法，還可以進行自訂義擴充(Extension)額外方法</li><li>它們都可以遵循Protocols</li></ul><h2>差異之處</h2><p>Class有的額外功能，且Structure沒有的</p><ul><li><a href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwi8yfPGo46CAxXFr1YBHaS_D4oQFnoECAoQAQ&url=https%3A%2F%2Fitisjoe.gitbooks.io%2Fswiftgo%2Fcontent%2Fch2%2Finheritance.html&usg=AOvVaw3owmh7jZ4g21R0OnO_JTFl&opi=89978449">繼承</a></li><li><a href="https://tommy60703.gitbooks.io/swift-language-traditional-chinese/content/chapter2/18_Type_Casting.html">型別轉換</a></li><li><a href="https://itisjoe.gitbooks.io/swiftgo/content/ch2/initialization_deinitialization.html#deinitializer">解構式</a></li><li><a href="https://tommy60703.gitbooks.io/swift-language-traditional-chinese/content/chapter2/16_Automatic_Reference_Counting.html">ARC(自動參考計數)</a></li></ul><p>其他不同的地方</p><ul><li>Value Type &amp; Reference Type</li><li>可變的(Mutable) &amp; 不可變的(Immutable)</li><li><a href="https://itisjoe.gitbooks.io/swiftgo/content/ch2/classes_structures.html#memberwise_initializer">Memberwise Initializer</a></li></ul><h2>語法</h2><p>這是定義出Structure跟Class最基本的程式碼，後面會繼續為你帶來實際的範例</p><pre><code><span class="keyword">struct</span> SomeStruct {
}
<span class="keyword">class</span> SomeClass {
}
</code></pre><h2>Value Type &amp; Reference Type</h2><p>Swift中的Structure是Value Type，這代表Structure的實例中的屬性，它們在你的程式碼中傳遞時都是會用複製值</p><pre><code><span class="keyword">struct</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>
}

<span class="keyword">let</span> andrew = <span class="type">Person</span>(name: <span class="string">"Andrew"</span>, age: <span class="number">22</span>)
<span class="keyword">var</span> eric = andrew

eric.<span class="property">age</span> = <span class="number">41</span>

<span class="call">print</span>(andrew.<span class="property">age</span>) <span class="comment">// print: 22</span>
<span class="call">print</span>(eric.<span class="property">age</span>) <span class="comment">// print: 41</span>
</code></pre><p>class是Reference Type，跟structure不同的是當你把class的實例指定給另一個變數，會參照到同一個位址，意思不管修改哪一個實例都是修改同一個，可以參考下面範例</p><pre><code><span class="keyword">class</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>

    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
        <span class="keyword">self</span>.<span class="property">age</span> = age
    }
}

<span class="keyword">let</span> andrew = <span class="type">Person</span>(name: <span class="string">"Andrew"</span>, age: <span class="number">22</span>)
<span class="keyword">var</span> eric = andrew

eric.<span class="property">age</span> = <span class="number">41</span>

<span class="call">print</span>(andrew.<span class="property">age</span>) <span class="comment">// print: 41</span>
<span class="call">print</span>(eric.<span class="property">age</span>) <span class="comment">// print: 41</span>
</code></pre><h2>建構子 Initializers</h2><p>在Swift中當你建立structure並且定義了一些屬性，structure會自動產生建構子(Initializer)它有一個專有名詞叫做<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/">Memberwise Initializer</a>，但是在class中並沒有這麼方便的功能，還是需要自己手動建立</p><pre><code><span class="comment">// struct</span>
<span class="keyword">struct</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>
}
<span class="keyword">let</span> leo = <span class="type">Person</span>(name: <span class="string">"Leo"</span>, age: <span class="number">32</span>)

<span class="comment">// class</span>
<span class="keyword">class</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>

    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
        <span class="keyword">self</span>.<span class="property">age</span> = age
    }
}
<span class="keyword">let</span> leo = <span class="type">Person</span>(name: <span class="string">"Leo"</span>, age: <span class="number">32</span>)
</code></pre><h2>使用 Mutating</h2><p>在structure裡預設你不能修改裡面的屬性，可使用關鍵字<code>mutating</code>來達成修改屬性的目的</p><p>可以參考Paul Husdon的這篇文章<a href="https://www.hackingwithswift.com/sixty/7/5/mutating-methods">Mutating methods</a></p><pre><code><span class="keyword">struct</span> Person {
    <span class="keyword">var</span> name: <span class="type">String</span>

    <span class="keyword">mutating func</span> setName(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">name</span> = name
    }
}
</code></pre><h2>參考來源</h2><ul><li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures">The Swift Programming Language</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://vickcoo.github.io/posts/Datecomponents@zh-Hant</guid><title>Different Between Date And DateComponenets</title><description>description</description><link>https://vickcoo.github.io/posts/Datecomponents@zh-Hant</link><pubDate>Thu, 1 Jan 1970 00:00:00 +0800</pubDate><content:encoded><![CDATA[<h1>Date 和 DateCompoents 有什麼不同?</h1>]]></content:encoded></item><item><guid isPermaLink="true">https://vickcoo.github.io/posts/WhatIsNewInXcode15@zh-Hant</guid><title>What's new in Xcode 15?</title><description>description</description><link>https://vickcoo.github.io/posts/WhatIsNewInXcode15@zh-Hant</link><pubDate>Thu, 1 Jan 1970 00:00:00 +0800</pubDate><content:encoded><![CDATA[]]></content:encoded></item></channel></rss>